# the inputs for this script are base species essential vs other species essential database blast result spreadsheets generated by blast_to_spreadsheet.py
# the outputs are spreadsheets showing the equivalent gene tags in other species for each blast query from the base species
# this script was used to create equivalency tables for blast results, these are the inputs for merge2.py which will create a single presence/absence matrix


import pandas as pd
import os
from glob import glob
from collections import defaultdict

def generate_presence_matrices_with_eval_resolution(input_folder, output_folder):
    os.makedirs(output_folder, exist_ok=True)
    blast_files = sorted(glob(os.path.join(input_folder, "*_essential_vs_*essentialdb.xlsx")))

    # Load all blast files into a lookup
    all_hits = defaultdict(lambda: defaultdict(list))  # {origin -> {target -> list of hits}}
    for filepath in blast_files:
        filename = os.path.basename(filepath)
        if "_essential_vs_" not in filename:
            continue

        origin, rest = filename.split("_essential_vs_")
        target = rest.replace("essentialdb.xlsx", "")
        if origin == target:
            continue

        df = pd.read_excel(filepath)
        for _, row in df.iterrows():
            query = str(row.get("query id"))
            subject = str(row.get("subject id"))
            evalue = row.get("evalue")
            if pd.isna(query) or pd.isna(subject) or pd.isna(evalue):
                continue
            all_hits[origin][target].append((query, subject, float(evalue)))

    # Resolve best matches accounting for bidirectional hits
    resolved_matches = defaultdict(lambda: defaultdict(dict))  # {origin -> {query -> {target: subject}}}
    for origin in all_hits:
        for target in all_hits[origin]:
            # Forward and reverse
            forward = all_hits[origin][target]
            reverse = all_hits[target][origin]

            # Build quick lookups
            forward_dict = {(q, s): e for q, s, e in forward}
            reverse_dict = {(s, q): e for q, s, e in reverse}

            used_queries = set()

            for (q, s), f_eval in forward_dict.items():
                if (q in used_queries): continue
                r_eval = reverse_dict.get((q, s), 50)  # Pretend reverse is just at threshold if missing
                best_eval = min(f_eval, r_eval)
                if best_eval == f_eval:
                    resolved_matches[origin][q][target] = s
                else:
                    resolved_matches[origin][q][target] = s  # Same subject; reverse had better evalue
                used_queries.add(q)

    # Write per-species presence matrix
    for origin_species, query_map in resolved_matches.items():
        all_queries = sorted(query_map.keys())
        all_targets = sorted({t for targets in query_map.values() for t in targets})
        matrix = pd.DataFrame(index=all_queries, columns=all_targets)

        for query, targets in query_map.items():
            for target, subject in targets.items():
                matrix.at[query, target] = subject

        output_path = os.path.join(output_folder, f"{origin_species}_presence_matrix.xlsx")
        matrix.to_excel(output_path)
        print(f"Saved matrix: {output_path}")

if __name__ == "__main__":
    input_dir = "./"                  # Folder with *_essential_vs_*essentialdb.xlsx files
    output_dir = "./resolved_matrices"
    generate_presence_matrices_with_eval_resolution(input_dir, output_dir)
